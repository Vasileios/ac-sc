[
{
	"uri": "https://vasileios.github.io/ac-sc/",
	"title": "AC",
	"tags": [],
	"description": "",
	"content": " AC Classes Algorithmic Composition \u0026amp; Sound Synthesis\n"
},
{
	"uri": "https://vasileios.github.io/ac-sc/introduction/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": "Chapter 1 History Music and maths.\nPythagoras\nThe sound of blacksmiths hammering had led Pythagoras to important conclusions about the nature of pitch and the mathematical basis of harmony after comparing the pitches made by hammers.\nGuido D'Arrezo\nAlso in the context of algorithmic composition, by around AD 1000 a first approach to automatic musical structure genesis had been developed. Guido of Arezzo (around 991–1031) contributed considerably to the development of notation, developed solmization and was an important music theorist of the medieval era. One of his most significant works, “Micrologus,” is the earliest compendium of monodic and polyphonic singing practice.\nArs Magna\nIf the abovementioned principles represent the beginnings of algorithmic manipulation of musical material, then the “Ars Magna” of Raimundus Lullus effectively realizes the concept of a computer (music) system.\nKircher\nIn his exhaustive musicologist work “Musurgia Universalis” from 1650, Kircher developed amongst others a system of algorithmic composition. This system consists of three categories of labeled wooden sticks (syntagmas) on which both numbers and rhythmic values are engraved.\nSee here more\nLeibniz (1646–1716)\n“universal language”\nFormalization of the sciences.\n..enable the solution of any scientific problem within a comprehensive calculus.\nThe concept of a universal language was also a vision of cross-national communication in Europe after the Thirty-Year War.\nProgramm's preconditions:\n Precompile encyclopedia of all terms that are necessary to formalize the sciences;   a formal system was to be developed, namely the “lingua universalis,” within which all scientific terms could be coded;   creating the “calculus ratiocinator” that should enable the connection of all terms of the universal language by means of logical operations.  Use of symbols to represent all scientific terms.\nAs a set of symbols, he chose the group of natural numbers.\nFor example,\n  Thing = 2  Being = 6=2*3  Human Being = 30=6*5  etc.  “Musica est exercitium arithmeticae occultum, nescientis se numerare animi” (“Music is a hidden arithmetic exercise of the soul, which does not know that it is counting.”).\nCalculating process \u0026 machines\nA mechanization of calculating processes, 1617 by the Scottish mathematician John Napier and Jost Bu ̈rgi (1552–1632) pioneered in the field of logarithms with his “Mirifici logarithmorum canonis descriptio” appearing in 1614, designed a device for multiplication and division, based on the principle of the Pythagorean abacus. (1550–1617).\nThe Napier’s abacus, also known as Napier’s bones.\n../images/NapiersBones.jpg\nSimilar to Napier's Bones:\nCaspar Schott (1608–1666), “Organum Mathematicum” (1668)\nLeibniz’ idea of applying the binary numeral system to an automaton was realized by an invention in the textile industry. In the year 1725, Basile Bouchon developed the first system for an automatic control of looms.\nBabbage-Lovelace 18th century\nBabbage’s main objective was the mechanization of calculation processes such as those that are required for the generation of logarithm tables.\nAlongside Babbage, Ada Countess of Lovelace (1815–1852) played an important role. She was a self-educated mathematician and worked together with Babbage on the concept of the “analytical engine.” In 1840, Babbage gave a course of lectures in Turin on his invention. On the basis of this material, the Italian mathematician Luigi Frederico Menabrea published the article “Notions sur la machine analytique de Charles Babbage” in 1842. Ada Lovelace translated this text to English in 1843 and added her own detailed considerations to the material, including the concepts of the loop, subroutine and the conditional jump. The Countess of Lovelace is considered to be the first female programmer in the history of informatics – the programming language Ada, developed in the 1970s, is named after her.\nFurthermore, first applications of algorithms for compositional tasks can be found in the popular “musical dice game” in the 18th century. (Nierhaus 2009)\nLogical Operations\nBoole (1815-1864)\nGeorge Boole (1815– 1864) developed in his publications “The Mathematical Analysis of Logic” (1847) and “An Investigation of the Laws of Thought” (1854) a formalism for the repre- sentation of propositional logic.\nShannon (1916-2001)\nBoolean algebra in electronic circuits\n\\alpha \\rightarrow \\beta\nX1V(X4(X2VX3))\n"
},
{
	"uri": "https://vasileios.github.io/ac-sc/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Algorithmic Composition Algorithm is:\n A set of mathematical instructions that must be followed in a fixed order, and that, especially if given to a computer, will help to calculate an answer to a mathematical problem [1]. A systematic procedure that produces – in a finite number of steps the answer to a question or the solution of a problem [2]. [...] (especially computing) a set of rules that must be followed when solving a particular problem [4]. (Nierhaus 2009 p.2)  "
},
{
	"uri": "https://vasileios.github.io/ac-sc/sc-examples/",
	"title": "Code Examples",
	"tags": [],
	"description": "",
	"content": "Chapter 2 SuperCollider examples of Sound Synthesis techniques and Algorithmic Composition.\n"
},
{
	"uri": "https://vasileios.github.io/ac-sc/introduction/paradigms/",
	"title": "Paradigms",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Paradigms  Markov models  Markov models are for the most part employed in the field of style imitation, but also, for example by Hiller and Xenakis, for applications of genuine composition.\n Generative grammars  Chomsky's generative grammars generation of musical structure\n Transition networks  David Cope’s program “EMI” “EMI” generates style imitations after having analyzed a sufficient number of compositions of a particular genre.\nEMI history\n chaos and self-similarity  Fractals, Lindenmayer systems\n Genetic algorithms   Cellular automata   Neural networks   Artificial intelligence  "
},
{
	"uri": "https://vasileios.github.io/ac-sc/sc-examples/supercollider/",
	"title": "SuperCollider",
	"tags": [],
	"description": "",
	"content": "SuperCollider SuperCollider From: SuperCollider\nBasics SuperCollider is a platform for audio synthesis and algorithmic composition, used by musicians, artists, and researchers working with sound. It is free and open source software available for Windows, macOS, and Linux.\nSuperCollider features three major components:  scsynth, a real-time audio server, forms the core of the platform. It features 400+ unit generators (\"UGens\") for analysis, synthesis, and processing. Its granularity allows the fluid combination of many known and unknown audio techniques, moving between additive and subtractive synthesis, FM, granular synthesis, FFT, and physical modelling. You can write your own UGens in C++, and users have already contributed several hundred more to the sc3-plugins repository. sclang, an interpreted programming language. It is focused on sound, but not limited to any specific domain. sclang controls scsynth via Open Sound Control. You can use it for algorithmic composition and sequencing, finding new sound synthesis methods, connecting your app to external hardware including MIDI controllers, network music, writing GUIs and visual displays, or for your daily programming experiments. It has a stock of user-contributed extensions called Quarks. scide is an editor for sclang with an integrated help system.  Find recordings folder thisProcess.platform.recordingsDir;  Sound synthesis techniques Introduction to sound synthesis and sound design (origin, definition, procedures, application fields).\n  SuperCollider example:  Creating a sine wave  {SinOsc.ar(440, 0, 0.3)}.play    Additive synthesis  {SinOsc.ar(440, 0, 0.4)+SinOsc.ar(660, 0, 0.3)}.play;    Subtractive synthesis  {LPF.ar(Saw.ar(440, 0.4), [3520, 4400, 5280], 0.3)}.play;    Granular synthesis  SynthDef(\\granular, {|out = 0, trig = 1, dur = 0.1, sndbuf, pos = 0.2, rate = 1, pan = 0, amp = 0.4| var env, source; env = EnvGen.kr(Env.adsr, 1, doneAcion: 2); source = Out.ar(out, GrainBuf.ar(2, Impulse.kr(trig), dur, sndbuf, rate, pos, 2, pan, envbuf) * env) }).add;  Input Devices Musical gestures can be expressed through a wide range of body movements. Dozens of input devices have been developed to capture these gestures. (Roads 1996: 625)\n  Switch  Push buttons  Linear potentiometer or fader  Trackball  Joystick  Game Paddles  etc  Instrument design Bela\nCapacitive touch sensor-raspberry pi\nMPR121\n  To be continued...  "
},
{
	"uri": "https://vasileios.github.io/ac-sc/introduction/tuning_scales/",
	"title": "Tuning-Scales",
	"tags": [],
	"description": "",
	"content": "chapter 1 Scales Circle of fiths is the relationship among the 12 tones of the chromatic scale, their corresponding key signatures, and the associated major and minor keys.\n../images/CircleOfFifths.jpg\n"
},
{
	"uri": "https://vasileios.github.io/ac-sc/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://vasileios.github.io/ac-sc/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]